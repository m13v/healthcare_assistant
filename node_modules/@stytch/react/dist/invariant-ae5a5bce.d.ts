import { Dispatch, SetStateAction } from "react";
declare const noProviderError: (item: string, provider?: string) => string;
declare const providerMustBeUniqueError = "You cannot render a <StytchProvider> inside another <StytchProvider>.";
declare const B2BProviderMustBeUniqueError = "You cannot render a <StytchB2BProvider> inside another <StytchB2BProvider>.";
declare const noSSRError = "The @stytch/react library is not meant for use with serverside environments like NextJS.\nUse the @stytch/nextjs library instead - \nnpm remove @stytch/react && npm install @stytch/nextjs\n";
declare const noHeadlessClientError = "Tried to create a Stytch Login UI element using the Stytch Headless SDK.\nYou must use the UI SDK to use UI elements.\nPlease make sure you are importing from @stytch/vanilla-js and not from the @stytch/vanilla-js/headless.";
// useState can cause memory leaks if it is set after the component unmounted. For example, if it is
// set after `await`, or in a `then`, `catch`, or `finally`, or in a setTimout/setInterval.
declare const useAsyncState: <T>(initialState: T | (() => T)) => [
    T,
    Dispatch<SetStateAction<T>>
];
/**
 * Returns a version of `newValue` whose properties that are deeply equal to
 * those in `oldValue` are replaced with those from `oldValue`. This provides a
 * limited form of "structural sharing" that provides a stable reference for
 * unchanged slices of the object.
 *
 * If `oldValue` and `newValue` are referentially equal, the same value is
 * returned.
 *
 * @param oldValue The old value
 * @param newValue The new value
 */
declare const mergeWithStableProps: <T extends Record<string, unknown>, U extends Record<string, unknown> = T>(oldValue: U, newValue: T) => T;
declare function invariant(cond: any, message: string): asserts cond;
export { noProviderError, providerMustBeUniqueError, B2BProviderMustBeUniqueError, noSSRError, noHeadlessClientError, useAsyncState, mergeWithStableProps, invariant };
